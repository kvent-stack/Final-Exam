---
title: "Data & Methods"
format:
  html:
    toc: true
    number-sections: true
execute:
  echo: false
  message: false
  warning: false
---
## Choose a Civic Problem & Define Research Question

Chicago faces persistent disparities in food access, with grocery stores disproportionately clustered in higher-income neighborhoods. This project examines how access to grocery stores varies across Chicago’s community areas, and how those patterns align with socioeconomic conditions. The analysis uses API-retrieved point-level data for food retailers and Census API demographics merged with community-area geometries.

## Data Acquisition

To build a reproducible pipeline for measuring neighborhood-level food retail access, I acquired two primary datasets through API calls: (1) Chicago’s business license dataset, which includes active food retailers, and (2) Chicago’s community area boundary file, which defines the geographic units of analysis. I also accessed tract-level population estimates from the 2022 American Community Survey (ACS) using the Census API.

```{r}
library(tidyverse)
library(sf)
library(tigris)
library(janitor)
library(arrow)
library(knitr)
library(scales)
library(ggplot2)
library(dplyr)
library(purrr)
library(tidyr)
library(leaflet)
library(tidycensus)

# Business license API pull
biz_url <- "https://data.cityofchicago.org/resource/xqx5-8hwx.geojson?$limit=50000"
biz <- st_read(biz_url)

# Community area boundaries API pull
chi_comm <- st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson?$limit=1000") %>%
  janitor::clean_names()

if ("community_area_name" %in% names(chi_comm)) {
  chi_comm <- chi_comm %>% rename(community = community_area_name)
}

# ACS tract-level population
acs_tracts <- get_acs(
  geography = "tract",
  variables = "B01003_001",
  state = "IL",
  county = "Cook",
  year = 2022,
  geometry = TRUE
) %>%
  st_as_sf() %>%
  janitor::clean_names() %>%
  mutate(population = estimate) %>%
  select(-estimate)
```

##Data Wrangling & Quality Checks

To prepare the business license dataset, I filtered for active food retailers and verified that the remaining records were complete and correctly structured.
```{r}
# Filter for active food retailers
grocery <- biz %>%
  filter(
    license_status %in% c("AAI", "AAC"),
    license_description %in% c(
      "Retail Food Establishment",
      "Wholesale Food Establishment",
      "Package Goods"
    )
  )

# Quality check: missingness and basic structure
missing_check <- sapply(grocery, function(x) sum(is.na(x)))
n_rows <- nrow(grocery)
head_rows <- grocery %>% st_drop_geometry() %>% head()

missing_check
n_rows
head_rows
```
[**Quality Check:**]{.underline} The missingness check shows that while the dataset is structurally intact, several fields contain non-critical gaps—most notably application_created_date, license_status_change_date, and ssa. These variables are administrative fields that do not affect spatial accuracy or the ability to identify active food retailers, so their missingness does not threaten the integrity of the analysis. Core fields required for this project—license status, license type, latitude/longitude coordinates, and community identifiers—are complete enough for reliable filtering and spatial joins. With 10,210 active food retail records, the dataset offers robust coverage across the city.


Next, I standardized coordinate systems for spatial alignment and assigned each food retailer to a community area through a point-in-polygon spatial join. I then aggregated food retail counts by community and checked for representation across all 77 areas.
```{r}
# Standardize CRS
grocery <- st_transform(grocery, st_crs(chi_comm))

# Spatial join to assign each retailer to a community area
grocery_joined <- st_join(grocery, chi_comm, join = st_within)

# Remove stores that fall outside community boundaries
grocery_joined <- grocery_joined %>%
  filter(!is.na(community))

# Count stores per community
store_counts <- grocery_joined %>%
  st_drop_geometry() %>%
  count(community, name = "store_count")

# Fix community naming inconsistencies (e.g., OHARE → O'HARE)
store_counts <- store_counts %>%
  mutate(
    community = recode(community,
      "OHARE" = "O'HARE"
    )
  )

# Quality check: distribution of counts + unique communities
summary(store_counts$store_count)
length(unique(store_counts$community))
```
[**Quality Check:**]{.underline} The spatial join successfully assigned nearly all food retailers to one of Chicago’s 77 community areas, but 62 records fell outside any boundary (primarily due to minor coordinate inconsistencies or locations near city edges). These were removed prior to aggregation to avoid artificially inflating totals or creating an unintended “78th” category.


To generate per-capita accessibility metrics, I pulled 2022 ACS total population estimates at the census tract level using the Census API, aligned the geometries with Chicago’s community boundaries, and used spatial intersection to aggregate tract populations into community-level totals.
```{r}
# Acquire ACS population estimates for Cook County tracts
acs_tracts <- get_acs(
  geography = "tract",
  variables = "B01003_001",
  state = "IL",
  county = "Cook",
  year = 2022,
  geometry = TRUE
) %>%
  st_as_sf() %>%
  janitor::clean_names() %>%
  mutate(population = estimate) %>%
  select(population, geometry)

# Align ACS geometry to community CRS
acs_tracts <- st_transform(acs_tracts, st_crs(chi_comm))

# Spatial intersection: assign tract population to community areas
tract_comm_join <- st_intersection(
  acs_tracts,
  chi_comm %>% select(community, geometry)
)

# Aggregate population to the community level
comm_pop <- tract_comm_join %>%
  st_drop_geometry() %>%
  group_by(community) %>%
  summarise(total_population = sum(population, na.rm = TRUE))

summary(comm_pop$total_population)
nrow(comm_pop)
any(comm_pop$total_population == 0)
```
[**Quality Check:**]{.underline} The aggregated ACS data return complete population estimates for all 77 community areas, with no zero-population values and no missing coverage. Population levels range from just over 20,000 in the smallest community to more than 200,000 in the largest, which aligns with Chicago’s known demographic structure. The absence of gaps or anomalies confirms that the tract-to-community spatial intersection performed correctly and that the resulting population totals are reliable for generating per-capita access measures.


To finalize the analytic dataset, I merged community polygons, aggregated population totals, and food retail counts into a single spatial dataframe, then computed a standardized measure of food access: stores per 10,000 residents.
```{r}
# Merge community polygons with store counts and population totals
chi_final <- chi_comm %>%
  left_join(store_counts, by = "community") %>%
  left_join(comm_pop, by = "community") %>%
  replace_na(list(store_count = 0)) %>%
  mutate(
    stores_per_10k = (store_count / total_population) * 10000
  )

# Quality check: verify dataset completeness
summary(chi_final$stores_per_10k)
nrow(chi_final)
any(is.na(chi_final$stores_per_10k))
```
[**Quality Check:**]{.underline} The final merged dataset includes all 77 Chicago community areas, and the stores_per_10k metric contains no missing values, confirming successful alignment across the business license and ACS population datasets. The accessibility distribution ranges from 0 stores per 10,000 residents in the lowest-access community to approximately 55 per 10,000 residents in the highest, with a median around 10.6. This spread indicates substantial neighborhood variation in food retail density and confirms that the dataset is well-structured and ready for summary statistics, visualization, and regression modeling.