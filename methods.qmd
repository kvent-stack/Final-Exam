---
title: "Data & Methods"
format:
  html:
    toc: true
    number-sections: true
execute:
  echo: true
  message: false
  warning: false
---

# Data Acquisition & Quality Control

To measure neighborhood-level access to food retailers, I assembled a reproducable data pipeline using three components: Chicago’s business-license dataset (to identify active retailers), community-area boundaries (to anchor spatial joins), and ACS tract-level population totals (to construct per-capita access measures).

```{r eval=FALSE}
biz_url = "https://data.cityofchicago.org/resource/xqx5-8hwx.geojson?$limit=50000"
biz = st_read(biz_url)

chi_comm = st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson?$limit=1000") %>%
  clean_names()

tracts_cc = tracts(state="IL", county="Cook", year=2022, cb=TRUE) %>%
  st_as_sf() %>% 
  clean_names()

acs_pop = get_acs(
  geography = "tract", 
  variables = "B01003_001",
  state = "IL",
  county = "Cook",
  year = 2022,
  geometry = FALSE
) %>% 
  clean_names() %>%
  transmute(geoid, population=estimate)

tracts_pop = tracts_cc %>%
  left_join(acs_pop, by="geoid") %>%
  st_transform(st_crs(chi_comm))

tract_comm_join = st_intersection(
  tracts_pop,
  chi_comm %>% select(community, geometry)
)

comm_pop = tract_comm_join %>%
  st_drop_geometry() %>%
  group_by(community) %>%
  summarise(total_population = sum(population, na.rm = TRUE))
```

```{r include=FALSE}
library(tidyverse)
library(sf)
library(tigris)
library(janitor)
library(tidycensus)

sf::sf_use_s2(FALSE)

biz_url = "https://data.cityofchicago.org/resource/xqx5-8hwx.geojson?$limit=50000"
biz = st_read(biz_url, quiet=TRUE)

grocery = biz %>%
  filter(
    license_status %in% c("AAI", "AAC"),
    license_description %in% c(
      "Retail Food Establishment",
      "Wholesale Food Establishment",
      "Package Goods"
    )
  )

chi_comm = st_read(
  "https://data.cityofchicago.org/resource/igwz-8jzy.geojson?$limit=1000",
  quiet=TRUE
) %>% clean_names()

if ("community_area_name" %in% names(chi_comm)) {
  chi_comm = chi_comm %>% rename(community = community_area_name)
}

tracts_cc = tracts(state="IL", county="Cook", year=2022, cb=TRUE) %>%
  st_as_sf() %>%
  clean_names()

acs_pop = get_acs(
  geography="tract",
  variables="B01003_001",
  state="IL",
  county="Cook",
  year=2022,
  geometry=FALSE,
  show_progress=FALSE
) %>%
  clean_names() %>%
  transmute(geoid, population=estimate)

tracts_pop = tracts_cc %>%
  left_join(acs_pop, by="geoid") %>%
  st_transform(st_crs(chi_comm))

tract_comm_join = st_intersection(
  tracts_pop,
  chi_comm %>% select(community, geometry)
)

comm_pop = tract_comm_join %>%
  st_drop_geometry() %>%
  group_by(community) %>%
  summarise(total_population=sum(population, na.rm=TRUE))
```

Before checking completeness and structure, I validated the underlying business-license file to ensure that the retailer records were suitable for filtering and spatial analysis.

```{r}
biz_missing = sapply(biz, \(x) sum(is.na(x)))
biz_rows = nrow(biz)
biz_cols = ncol(biz)

biz_rows
biz_cols
biz_missing[1:10]
```

[**Quality Check:**]{.underline} The business-license dataset loads cleanly with 50,000 rows and 41 fields, and all essential analytical columns (license status, license ID, and geocoded points for active retailers) show no missingness. Missing values appear primarily in older or administrative fields such as location_state, location_zip, and latitude, but these gaps do not interfere with filtering active food retailers or performing spatial joins. Overall, the file provides a complete and reliable foundation for constructing the retailer inventory.

------------------------------------------------------------------------

I next verified the integrity of Chicago’s community-area geometries, as accurate spatial boundaries are essential for assigning retailers and population counts to neighborhoods.

```{r}
unique_comms = length(unique(chi_comm$community))
geom_valid = all(st_is_valid(chi_comm))

unique_comms
geom_valid
```

[**Quality Check:**]{.underline} The community-area boundary file includes all 77 Chicago community areas, and all geometries are valid with no null polygons or duplicate identifiers. CRS metadata is intact, confirming it is suitable as the spatial index for point-in-polygon operations.

------------------------------------------------------------------------

I also assessed the ACS tract-level population estimates to confirm that the demographic denominators used in per-capita calculations were complete and correctly aligned with community boundaries.

```{r}
acs_rows = nrow(acs_pop)
any_na_pop = any(is.na(acs_pop$population))
summary(acs_pop$population)
```

[**Quality Check:**]{.underline} ACS population estimates load cleanly for all Cook County tracts intersecting Chicago. No missing population values appear, and the distribution aligns with expected tract-level variation. After joining to tract geometries, all tracts successfully intersect with community polygons, producing complete community-level population totals.

------------------------------------------------------------------------

Next, I standardized coordinate systems for spatial alignment and assigned each food retailer to a community area through a point-in-polygon spatial join. I then aggregated food retail counts by community and checked for representation across all 77 areas.

```{r}
grocery = st_transform(grocery, st_crs(chi_comm))

grocery_joined = st_join(grocery, chi_comm, join = st_within) %>%
  filter(!is.na(community))

store_counts = grocery_joined %>%
  st_drop_geometry() %>%
  count(community, name = "store_count") %>%
  mutate(community = recode(community, "OHARE" = "O'HARE"))

summary(store_counts$store_count)
length(unique(store_counts$community))
```

[**Quality Check:**]{.underline} The spatial join successfully assigned nearly all food retailers to one of Chicago’s 77 community areas, but 62 records fell outside any boundary (primarily due to minor coordinate inconsistencies or locations near city edges). These were removed prior to aggregation to avoid artificially inflating totals or creating an unintended “78th” category.

------------------------------------------------------------------------

To finalize the dataset, I merged community polygons, aggregated population totals, and food retail counts into a single spatial dataframe, then computed a standardized measure of food access: stores per 10,000 residents.

```{r echo=TRUE}
chi_final = chi_comm %>%
  left_join(store_counts, by = "community") %>%
  left_join(comm_pop, by = "community") %>%
  replace_na(list(store_count = 0)) %>%
  mutate(stores_per_10k = (store_count / total_population) * 10000)

saveRDS(chi_final, "data/chi_final.rds")

summary(chi_final$stores_per_10k)
nrow(chi_final)
any(is.na(chi_final$stores_per_10k))
```

[**Quality Check:**]{.underline} The finalized dataset includes all 77 Chicago community areas, and the *stores_per_10k* metric contains no missing values, confirming that both retailer counts and population totals aligned correctly during the merge. The per-capita access distribution now ranges from 0 to 291 stores per 10,000 residents, with a median of 46.66 and a wide interquartile range spanning roughly 35 to 76. The absence of missing values, combined with the plausible and interpretable distribution, indicates that the dataset is structurally sound and ready for visualization and modeling.
