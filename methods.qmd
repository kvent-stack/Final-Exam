---
title: "Data & Methods"
format:
  html:
    toc: true
    number-sections: true
execute:
  echo: true
  message: false
  warning: false
---

# Data Acquisition

To measure neighborhood-level access to food retailers, I assembled a reproducible pipeline using three components: Chicago’s business-license dataset (to identify active retailers), community-area boundaries (to anchor spatial joins), and ACS tract-level population totals (to construct per-capita access measures).

```{r eval=FALSE}
biz_url = "https://data.cityofchicago.org/resource/xqx5-8hwx.geojson?$limit=50000"
biz = st_read(biz_url)

chi_comm = st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson?$limit=1000") %>%
  clean_names()

tracts_cc = tracts(state="IL", county="Cook", year=2022, cb=TRUE) %>%
  st_as_sf() %>% 
  clean_names()

acs_pop = get_acs(
  geography = "tract", 
  variables = "B01003_001",
  state = "IL",
  county = "Cook",
  year = 2022,
  geometry = FALSE
) %>% 
  clean_names() %>%
  transmute(geoid, population=estimate)

tracts_pop = tracts_cc %>%
  left_join(acs_pop, by="geoid") %>%
  st_transform(st_crs(chi_comm))

tract_comm_join = st_intersection(
  tracts_pop,
  chi_comm %>% select(community, geometry)
)

comm_pop = tract_comm_join %>%
  st_drop_geometry() %>%
  group_by(community) %>%
  summarise(total_population = sum(population, na.rm = TRUE))
```

```{r include=FALSE}
library(tidyverse)
library(sf)
library(tigris)
library(janitor)
library(tidycensus)

sf::sf_use_s2(FALSE)

biz_url = "https://data.cityofchicago.org/resource/xqx5-8hwx.geojson?$limit=50000"
biz = st_read(biz_url, quiet=TRUE)

chi_comm = st_read(
  "https://data.cityofchicago.org/resource/igwz-8jzy.geojson?$limit=1000",
  quiet=TRUE
) %>% clean_names()

if ("community_area_name" %in% names(chi_comm)) {
  chi_comm = chi_comm %>% rename(community = community_area_name)
}

tracts_cc = tracts(state="IL", county="Cook", year=2022, cb=TRUE) %>%
  st_as_sf() %>%
  clean_names()

acs_pop = get_acs(
  geography="tract",
  variables="B01003_001",
  state="IL",
  county="Cook",
  year=2022,
  geometry=FALSE,
  show_progress=FALSE
) %>%
  clean_names() %>%
  transmute(geoid, population=estimate)

tracts_pop = tracts_cc %>%
  left_join(acs_pop, by="geoid") %>%
  st_transform(st_crs(chi_comm))

tract_comm_join = st_intersection(
  tracts_pop,
  chi_comm %>% select(community, geometry)
)

comm_pop = tract_comm_join %>%
  st_drop_geometry() %>%
  group_by(community) %>%
  summarise(total_population=sum(population, na.rm=TRUE))
```

# Data Wrangling & Quality Checks

To prepare the business license dataset, I filtered for active food retailers and verified that the remaining records were complete and correctly structured.

```{r}
grocery = biz %>%
  filter(
    license_status %in% c("AAI", "AAC"),
    license_description %in% c(
      "Retail Food Establishment", 
      "Wholesale Food Establishment",
      "Package Goods"
    )
  )

missing_check = sapply(grocery, \(x) sum(is.na(x)))
n_rows = nrow(grocery)
head_rows = grocery %>% st_drop_geometry() %>% head(10)

missing_check
n_rows
head_rows
```

[**Quality Check:**]{.underline} The missingness pattern confirms that the gaps occur primarily in administrative timestamp fields rather than in coordinates or licensing descriptors. Because the core spatial and classification variables are intact, the dataset is suitable for retailer identification and spatial assignment.

------------------------------------------------------------------------

Next, I standardized coordinate systems for spatial alignment and assigned each food retailer to a community area through a point-in-polygon spatial join. I then aggregated food retail counts by community and checked for representation across all 77 areas.

```{r}
grocery = st_transform(grocery, st_crs(chi_comm))

grocery_joined = st_join(grocery, chi_comm, join = st_within) %>%
  filter(!is.na(community))

store_counts = grocery_joined %>%
  st_drop_geometry() %>%
  count(community, name = "store_count") %>%
  mutate(community = recode(community, "OHARE" = "O'HARE"))

summary(store_counts$store_count)
length(unique(store_counts$community))
```

[**Quality Check:**]{.underline} The spatial join successfully assigned nearly all food retailers to one of Chicago’s 77 community areas, but 62 records fell outside any boundary (primarily due to minor coordinate inconsistencies or locations near city edges). These were removed prior to aggregation to avoid artificially inflating totals or creating an unintended “78th” category.

------------------------------------------------------------------------

To finalize the analytic dataset, I merged community polygons, aggregated population totals, and food retail counts into a single spatial dataframe, then computed a standardized measure of food access: stores per 10,000 residents.

```{r echo=TRUE}
chi_final = chi_comm %>%
  left_join(store_counts, by = "community") %>%
  left_join(comm_pop, by = "community") %>%
  replace_na(list(store_count = 0)) %>%
  mutate(stores_per_10k = (store_count / total_population) * 10000)

saveRDS(chi_final, "data/chi_final.rds")

summary(chi_final$stores_per_10k)
nrow(chi_final)
any(is.na(chi_final$stores_per_10k))
```

[**Quality Check:**]{.underline} The final merged dataset includes all 77 Chicago community areas, and the stores_per_10k metric contains no missing values, confirming successful alignment across the business license and ACS population datasets. The accessibility distribution ranges from 0 stores per 10,000 residents in the lowest-access community to approximately 55 per 10,000 residents in the highest, with a median around 10.6. This spread indicates substantial neighborhood variation in food retail density and confirms that the dataset is well-structured and ready for summary statistics, visualization, and regression modeling.
